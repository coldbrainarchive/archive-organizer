<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Archive</title>

<style>
html,body{
  margin:0;
  width:100%;
  height:100%;
  background:#000;
  overflow:hidden;
}
canvas{ position:fixed; inset:0; }

#fade{
  position:fixed;
  inset:0;
  background:#000;
  opacity:0;
  pointer-events:none;
  transition:opacity .45s ease;
  z-index:5;
}

video{
  position:fixed;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
  background:#000;
  z-index:10;
  transition:opacity .4s ease;
}

#uploader{
  position:fixed;
  opacity:0;
  pointer-events:none;
}
</style>
</head>

<body>

<canvas id="c"></canvas>
<div id="fade"></div>
<input id="uploader" type="file" accept="video/*" capture="environment">

<script>
const API="/api/random";

/***********************
 * STATE
 ***********************/
let audioCtx=null;
let playing=false;
let currentVideo=null;

/***********************
 * CAMERA (INERTIA)
 ***********************/
let camX=0, camY=0;
let velX=0, velY=0;
let dragging=false;
let lastX=0,lastY=0;

const FRICTION=0.95;
const DRAG_SPEED=1;
const VELOCITY_SCALE=0.9;

/***********************
 * CANVAS
 ***********************/
const canvas=document.getElementById("c");
const ctx=canvas.getContext("2d");
let W,H;

function resize(){
  W=canvas.width=innerWidth;
  H=canvas.height=innerHeight;
}
addEventListener("resize",resize);
resize();

/***********************
 * PARTICLES
 ***********************/
const DEPTHS = [0.45, 0.7, 1];
let particles = [];

function createParticles(){
  particles = [];
  const TOTAL = 90;
  const UPLOAD_COUNT = Math.floor(TOTAL * 0.05);
  let created = 0;

  for(const d of DEPTHS){
    for(let i = 0; i < 30; i++){
      const isUpload = created < UPLOAD_COUNT;
      created++;

      const baseRadius = isUpload
        ? (Math.random() * 6 + 8)
        : (Math.random() * 2 + 1);

      particles.push({
        /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           POSITION
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        x: Math.random() * W * 2,
        y: Math.random() * H * 2,

        /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           DEPTH & SIZE
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        depth: d,
        r: baseRadius * d,

        /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           MOTION
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        vx: (Math.random() - 0.5) * 0.25 * d,
        vy: (Math.random() - 0.5) * 0.25 * d,

        /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           VISIBILITY
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
        a: isUpload ? 1 : 0.12 + d * 0.65,
        isUpload,

        /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           âœ¨ LIFE / GLOW SYSTEM (BLOOM READY)
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

        // breathing phase (used every frame)
        pulse: Math.random() * Math.PI * 2,

        // very slow, massive breathing
        pulseSpeed: 0.0007 + Math.random() * 0.0014,

        // huge brightness modulation
        pulseStrength: 7.5 + Math.random() * 11.5,

        // EXTREME glow baseline (expects additive blending)
        glowBoost: 130 + Math.random() * 210,

        /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
           ğŸŒŸ FLARE SYSTEM (HOT + VISIBLE)
        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

        // current flare energy
        flare: 0,

        // frequent stellar flares
        flareChance: 0.004 + Math.random() * 0.006,

        // slow decay so flares bloom outward
        flareDecay: 0.90 + Math.random() * 0.04
      });
    }
  }
}

createParticles();
/***********************
 * SHOCKWAVES (UPLOAD)
 ***********************/
const shockwaves=[];
function addShockwave(x,y){
  shockwaves.push({ x,y,r:0,max:220,alpha:1 });
}

/***********************
 * MODULO
 ***********************/
function mod(n,m){ return ((n%m)+m)%m; }

/***********************
 * DRAW LOOP â€” TRUE BLOOM Ã—3 (SLOWER BREATHING)
 ***********************/
function draw(){
  ctx.clearRect(0, 0, W, H);

  if(!dragging){
    camX += velX;
    camY += velY;
    velX *= FRICTION;
    velY *= FRICTION;
  }

  const fw = W * 2;
  const fh = H * 2;

  // ğŸŒ¬ GLOBAL BREATH â€” slower + deeper
  const time = performance.now();
  const globalBreath =
    0.92 + Math.sin(time * 0.00011) * 0.08;
/* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   ğŸŒ«ï¸ AMBIENT BACKDROP HAZE
   (subtle, global, non-directional)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
ctx.globalCompositeOperation = "screen";

const hazeStrength =
  0.025 + Math.sin(time * 0.00004) * 0.01;

const gradient = ctx.createRadialGradient(
  W * 0.5, H * 0.5, 0,
  W * 0.5, H * 0.5, Math.max(W, H)
);

gradient.addColorStop(0, `rgba(200,220,255,${hazeStrength})`);
gradient.addColorStop(1, `rgba(0,0,0,0)`);

ctx.fillStyle = gradient;
ctx.fillRect(0, 0, W, H);

ctx.globalCompositeOperation = "lighter";
  ctx.globalCompositeOperation = "lighter";

  for(const p of particles){
    if(p.a <= 0) continue;

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       MOTION
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    p.x += p.vx;
    p.y += p.vy;
    p.x = mod(p.x, fw);
    p.y = mod(p.y, fh);

    const rx = mod(p.x - camX * p.depth, fw);
    const ry = mod(p.y - camY * p.depth, fh);
    const sx = rx - fw/2 + W/2;
    const sy = ry - fh/2 + H/2;

    if(sx < -450 || sx > W + 450 || sy < -450 || sy > H + 450) continue;

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       ğŸ« BREATHING ENERGY (SLOW)
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

    // â³ slow pulse advance slightly
    p.pulse += p.pulseSpeed * 0.72;

    if(Math.random() < p.flareChance){
      p.flare = 2.5 + Math.random() * 4;
    }
    p.flare *= p.flareDecay;

    const breath =
      1 + Math.sin(p.pulse) * (p.pulseStrength * 0.6);

    const flareEnergy = p.flare * 4;

    let life = breath + flareEnergy;

    // soft compression (unchanged)
    life = 1 + Math.tanh(life * 0.35);

    const depthBoost = 0.6 + p.depth * 1.8;

    const glow =
      p.glowBoost *
      life *
      depthBoost *
      globalBreath *
      2.2;

    // ğŸ« slower size breathing
    const sizeBreath =
      1 + Math.sin(p.pulse * 0.7) * 0.045;

    const exposure =
      0.35 + Math.pow(life, 0.85) * 0.75;

    /* â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       ğŸŒ«ï¸ BLOOM PASSES
    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

    ctx.shadowBlur = glow * 5.2;
    ctx.shadowColor = `rgba(255,255,255,${0.06 * exposure})`;
    ctx.beginPath();
    ctx.arc(sx, sy, p.r * 3.6 * sizeBreath, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,255,${0.01 * exposure})`;
    ctx.fill();

    ctx.shadowBlur = glow * 4.0;
    ctx.shadowColor = `rgba(255,255,255,${0.12 * exposure})`;
    ctx.beginPath();
    ctx.arc(sx, sy, p.r * 2.8 * sizeBreath, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,255,${0.02 * exposure})`;
    ctx.fill();

    ctx.shadowBlur = glow * 2.8;
    ctx.shadowColor = `rgba(255,255,255,${0.22 * exposure})`;
    ctx.beginPath();
    ctx.arc(sx, sy, p.r * 2.1 * sizeBreath, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,255,${0.045 * exposure})`;
    ctx.fill();

    ctx.shadowBlur = glow * 1.8;
    ctx.shadowColor = `rgba(255,255,255,${0.5 * exposure})`;
    ctx.beginPath();
    ctx.arc(sx, sy, p.r * 1.5 * sizeBreath, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(255,255,255,${0.12 * exposure})`;
    ctx.fill();

    ctx.shadowBlur = glow * 0.9;
    ctx.shadowColor = "rgba(255,255,255,1)";
    ctx.beginPath();
    ctx.arc(sx, sy, p.r * 1.1 * sizeBreath, 0, Math.PI * 2);

    if(p.isUpload){
      ctx.strokeStyle = "rgba(255,255,255,1)";
      ctx.lineWidth = 2.4 + p.depth * 1.8;
      ctx.stroke();
    }else{
      ctx.fillStyle = `rgba(255,255,255,${p.a * exposure})`;
      ctx.fill();
    }

    ctx.shadowBlur = 0;
  }

  /* SHOCKWAVES â€” unchanged */
  for(let i = shockwaves.length - 1; i >= 0; i--){
    const s = shockwaves[i];
    s.r += 10;
    s.alpha *= 0.92;

    if(s.r > s.max || s.alpha < 0.02){
      shockwaves.splice(i, 1);
      continue;
    }

    ctx.shadowBlur = 160;
    ctx.shadowColor = "rgba(255,255,255,1)";
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
    ctx.strokeStyle = `rgba(255,255,255,${s.alpha})`;
    ctx.lineWidth = 3;
    ctx.stroke();
    ctx.shadowBlur = 0;
  }

  ctx.globalCompositeOperation = "source-over";
  requestAnimationFrame(draw);
}

draw();
/***********************
 * AUDIO
 ***********************/
function unlockAudio(){
  if(!audioCtx){
    audioCtx=new (window.AudioContext||window.webkitAudioContext)();
  }
  if(audioCtx.state!=="running") audioCtx.resume();
}

/***********************
 * CAMERA INPUT
 ***********************/
canvas.addEventListener("pointerdown",e=>{
  dragging=true;
  lastX=e.clientX;
  lastY=e.clientY;
  velX=velY=0;
});
addEventListener("pointermove",e=>{
  if(!dragging) return;
  const dx=e.clientX-lastX;
  const dy=e.clientY-lastY;
  camX-=dx*DRAG_SPEED;
  camY-=dy*DRAG_SPEED;
  velX=-dx*VELOCITY_SCALE;
  velY=-dy*VELOCITY_SCALE;
  lastX=e.clientX;
  lastY=e.clientY;
});
addEventListener("pointerup",()=>dragging=false);
addEventListener("pointercancel",()=>dragging=false);

/***********************
 * CLICK HANDLING + WATER RIPPLE
 ***********************/
const uploader = document.getElementById("uploader");

canvas.addEventListener("click", e => {
  if(dragging || playing) return;
  unlockAudio();

  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  const fw = W * 2;
  const fh = H * 2;

  let hit = false;

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 1ï¸âƒ£ DIRECT PARTICLE HIT
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  for(const p of particles){
    if(p.a <= 0) continue;

    const rx = mod(p.x - camX * p.depth, fw);
    const ry = mod(p.y - camY * p.depth, fh);
    const sx = rx - fw/2 + W/2;
    const sy = ry - fh/2 + H/2;

    if(Math.hypot(mx - sx, my - sy) <= p.r + 12){
      hit = true;

      if(p.isUpload){
        addShockwave(sx, sy);
        p.a = 0;
        setTimeout(openCamera, 500);
      }else{
        explode(p.x, p.y);
        playRandom();
      }
      break;
    }
  }

  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // 2ï¸âƒ£ WATER RIPPLE (EMPTY SPACE OR NEAR MISS)
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if(!hit){
    ripple(mx, my);
  }
});

/***********************
 * WATER RIPPLE FUNCTION
 ***********************/
function ripple(mx, my){
  const RADIUS   = 160;  // ripple reach
  const STRENGTH = 0.6;  // softness
  const fw = W * 2;
  const fh = H * 2;

  for(const p of particles){
    if(p.a <= 0) continue;

    // particle â†’ screen space
    const rx = mod(p.x - camX * p.depth, fw);
    const ry = mod(p.y - camY * p.depth, fh);
    const sx = rx - fw/2 + W/2;
    const sy = ry - fh/2 + H/2;

    const dx = sx - mx;
    const dy = sy - my;
    const d  = Math.hypot(dx, dy);

    if(d > 0 && d < RADIUS){
      const force = (1 - d / RADIUS) * STRENGTH;

      // gentle push away from finger
      p.vx += (dx / d) * force * p.depth;
      p.vy += (dy / d) * force * p.depth;
    }
  }
}

/***********************
 * CAMERA UPLOAD
 ***********************/
function openCamera(){
  uploader.value="";
  uploader.click();
}

/***********************
 * EXPLOSION
 ***********************/
function explode(cx,cy){
  for(const p of particles){
    const d=Math.hypot(p.x-cx,p.y-cy);
    if(d<140){
      const f=(1-d/140)*6;
      p.vx+=(p.x-cx)/d*f||0;
      p.vy+=(p.y-cy)/d*f||0;
    }
  }
}

/***********************
 * VIDEO FLOW
 ***********************/
async function playRandom(){
  playing=true;
  velX=velY=0;
  setTimeout(()=>fade(1),200);

  try{
    const res=await fetch(API);
    const data=await res.json();
    if(!data.ok||!data.url){ reset(); return; }
    setTimeout(()=>playVideo(data.url),420);
  }catch{
    reset();
  }
}

function playVideo(url){
  const vid=document.createElement("video");
  currentVideo=vid;
  vid.src=url;
  vid.muted=true;
  vid.autoplay=true;
  vid.playsInline=true;
  vid.style.opacity=0;
  document.body.appendChild(vid);

  vid.onplaying=()=>{
    vid.style.opacity=1;
    setTimeout(()=>vid.muted=false,200);
  };

  vid.addEventListener("pointerdown", exitVideo);
  vid.onended=exitVideo;
  vid.onerror=exitVideo;
}

function exitVideo(){
  if(!currentVideo) return;
  fade(1);
  currentVideo.style.opacity=0;
  setTimeout(()=>{
    currentVideo.pause();
    currentVideo.remove();
    currentVideo=null;
    reset();
  },350);
}

/***********************
 * HELPERS
 ***********************/
function fade(v){
  document.getElementById("fade").style.opacity=v;
}
function reset(){
  fade(0);
  playing=false;
  camX=camY=velX=velY=0;
  createParticles();
}
</script>

</body>
</html>
