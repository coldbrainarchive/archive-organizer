<!doctype html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Archive</title>

<style>
html,body{
  margin:0;
  width:100%;
  height:100%;
  background:#000;
  overflow:hidden;
}
canvas{ position:fixed; inset:0; }

#fade{
  position:fixed;
  inset:0;
  background:#000;
  opacity:0;
  pointer-events:none;
  transition:opacity .45s ease;
  z-index:5;
}

video{
  position:fixed;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
  background:#000;
  z-index:10;
  transition:opacity .4s ease;
}

#uploader{
  position:fixed;
  opacity:0;
  pointer-events:none;
}
</style>
</head>

<body>

<canvas id="c"></canvas>
<div id="fade"></div>
<input id="uploader" type="file" accept="video/*" capture="environment">

<script>
const API="/api/random";

/***********************
 * STATE
 ***********************/
let audioCtx=null;
let playing=false;
let currentVideo=null;

/***********************
 * CAMERA (INERTIA)
 ***********************/
let camX=0, camY=0;
let velX=0, velY=0;
let dragging=false;
let lastX=0,lastY=0;

const FRICTION=0.95;
const DRAG_SPEED=1;
const VELOCITY_SCALE=0.9;

/***********************
 * CANVAS
 ***********************/
const canvas=document.getElementById("c");
const ctx=canvas.getContext("2d");
let W,H;

function resize(){
  W=canvas.width=innerWidth;
  H=canvas.height=innerHeight;
}
addEventListener("resize",resize);
resize();

/***********************
 * PARTICLES
 ***********************/
const DEPTHS=[0.45,0.7,1];
let particles=[];

function createParticles(){
  particles=[];
  const TOTAL=90;
  const UPLOAD_COUNT=Math.floor(TOTAL*0.05);
  let created=0;

  for(const d of DEPTHS){
    for(let i=0;i<30;i++){
      const isUpload=created<UPLOAD_COUNT;
      created++;

      const baseRadius=isUpload
        ? (Math.random()*6+8)
        : (Math.random()*2+1);

      particles.push({
        x:Math.random()*W*2,
        y:Math.random()*H*2,
        depth:d,
        r:baseRadius*d,
        vx:(Math.random()-.5)*0.25*d,
        vy:(Math.random()-.5)*0.25*d,
        a:isUpload ? 1 : 0.12+d*0.65,
        isUpload
      });
    }
  }
}
createParticles();

/***********************
 * SHOCKWAVES (UPLOAD)
 ***********************/
const shockwaves=[];
function addShockwave(x,y){
  shockwaves.push({ x,y,r:0,max:220,alpha:1 });
}

/***********************
 * MODULO
 ***********************/
function mod(n,m){ return ((n%m)+m)%m; }

/***********************
 * DRAW LOOP
 ***********************/
function draw(){
  ctx.clearRect(0,0,W,H);

  if(!dragging){
    camX+=velX;
    camY+=velY;
    velX*=FRICTION;
    velY*=FRICTION;
  }

  const fw=W*2, fh=H*2;

  for(const p of particles){
    if(p.a<=0) continue;

    p.x+=p.vx;
    p.y+=p.vy;
    p.x=mod(p.x,fw);
    p.y=mod(p.y,fh);

    const rx=mod(p.x-camX*p.depth,fw);
    const ry=mod(p.y-camY*p.depth,fh);
    const sx=rx-fw/2+W/2;
    const sy=ry-fh/2+H/2;

    if(sx<-100||sx>W+100||sy<-100||sy>H+100) continue;

    ctx.shadowBlur=6+p.depth*14;
    ctx.shadowColor="rgba(255,255,255,0.35)";
    ctx.beginPath();
    ctx.arc(sx,sy,p.r,0,Math.PI*2);

    if(p.isUpload){
      ctx.strokeStyle="rgba(255,255,255,0.9)";
      ctx.lineWidth=1.5;
      ctx.stroke();
    }else{
      ctx.fillStyle=`rgba(255,255,255,${p.a})`;
      ctx.fill();
    }
    ctx.shadowBlur=0;
  }

  /* WHITE SHOCKWAVES */
  for(let i=shockwaves.length-1;i>=0;i--){
    const s=shockwaves[i];
    s.r+=10;
    s.alpha*=0.92;

    if(s.r>s.max||s.alpha<0.02){
      shockwaves.splice(i,1);
      continue;
    }

    ctx.beginPath();
    ctx.arc(s.x,s.y,s.r,0,Math.PI*2);
    ctx.strokeStyle=`rgba(255,255,255,${s.alpha})`;
    ctx.lineWidth=2;
    ctx.shadowBlur=30;
    ctx.shadowColor="rgba(255,255,255,1)";
    ctx.stroke();
    ctx.shadowBlur=0;
  }

  requestAnimationFrame(draw);
}
draw();

/***********************
 * AUDIO
 ***********************/
function unlockAudio(){
  if(!audioCtx){
    audioCtx=new (window.AudioContext||window.webkitAudioContext)();
  }
  if(audioCtx.state!=="running") audioCtx.resume();
}

/***********************
 * CAMERA INPUT
 ***********************/
canvas.addEventListener("pointerdown",e=>{
  dragging=true;
  lastX=e.clientX;
  lastY=e.clientY;
  velX=velY=0;
});
addEventListener("pointermove",e=>{
  if(!dragging) return;
  const dx=e.clientX-lastX;
  const dy=e.clientY-lastY;
  camX-=dx*DRAG_SPEED;
  camY-=dy*DRAG_SPEED;
  velX=-dx*VELOCITY_SCALE;
  velY=-dy*VELOCITY_SCALE;
  lastX=e.clientX;
  lastY=e.clientY;
});
addEventListener("pointerup",()=>dragging=false);
addEventListener("pointercancel",()=>dragging=false);

/***********************
 * INTERACTION (TAP + RIPPLE)
 ***********************/
const uploader = document.getElementById("uploader");

let touching = false;
let touchX = 0;
let touchY = 0;

canvas.addEventListener("pointerdown", e => {
  if(playing) return;
  unlockAudio();

  touching = true;

  const rect = canvas.getBoundingClientRect();
  touchX = e.clientX - rect.left;
  touchY = e.clientY - rect.top;

  handleTap(touchX, touchY);
});

canvas.addEventListener("pointermove", e => {
  if(!touching) return;

  const rect = canvas.getBoundingClientRect();
  touchX = e.clientX - rect.left;
  touchY = e.clientY - rect.top;

  // ðŸŒŠ continuous ripple while finger moves
  const wx = touchX + camX;
  const wy = touchY + camY;
  ripple(wx, wy, 0.35);
});

canvas.addEventListener("pointerup", () => {
  touching = false;
});

canvas.addEventListener("pointercancel", () => {
  touching = false;
});

/***********************
 * TAP RESOLUTION
 ***********************/
function handleTap(mx, my){
  const fw = W * 2;
  const fh = H * 2;

  let hit = false;

  for(const p of particles){
    if(p.a <= 0) continue;

    const rx = mod(p.x - camX * p.depth, fw);
    const ry = mod(p.y - camY * p.depth, fh);
    const sx = rx - fw/2 + W/2;
    const sy = ry - fh/2 + H/2;

    if(Math.hypot(mx - sx, my - sy) <= p.r + 12){
      hit = true;

      if(p.isUpload){
        addShockwave(sx, sy);
        p.a = 0;
        setTimeout(openCamera, 500);
      }else{
        explode(p.x, p.y);
        playRandom();
      }
      break;
    }
  }

  // ðŸŒŠ initial ripple if empty space
  if(!hit){
    const wx = mx + camX;
    const wy = my + camY;
    ripple(wx, wy, 0.8);
  }
}

/***********************
 * CAMERA UPLOAD
 ***********************/
function openCamera(){
  uploader.value="";
  uploader.click();
}

/***********************
 * EXPLOSION
 ***********************/
function explode(cx,cy){
  for(const p of particles){
    const d=Math.hypot(p.x-cx,p.y-cy);
    if(d<140){
      const f=(1-d/140)*6;
      p.vx+=(p.x-cx)/d*f||0;
      p.vy+=(p.y-cy)/d*f||0;
    }
  }
}

/***********************
 * VIDEO FLOW
 ***********************/
async function playRandom(){
  playing=true;
  velX=velY=0;
  setTimeout(()=>fade(1),200);

  try{
    const res=await fetch(API);
    const data=await res.json();
    if(!data.ok||!data.url){ reset(); return; }
    setTimeout(()=>playVideo(data.url),420);
  }catch{
    reset();
  }
}

function playVideo(url){
  const vid=document.createElement("video");
  currentVideo=vid;
  vid.src=url;
  vid.muted=true;
  vid.autoplay=true;
  vid.playsInline=true;
  vid.style.opacity=0;
  document.body.appendChild(vid);

  vid.onplaying=()=>{
    vid.style.opacity=1;
    setTimeout(()=>vid.muted=false,200);
  };

  vid.addEventListener("pointerdown", exitVideo);
  vid.onended=exitVideo;
  vid.onerror=exitVideo;
}

function exitVideo(){
  if(!currentVideo) return;
  fade(1);
  currentVideo.style.opacity=0;
  setTimeout(()=>{
    currentVideo.pause();
    currentVideo.remove();
    currentVideo=null;
    reset();
  },350);
}

/***********************
 * HELPERS
 ***********************/
function fade(v){
  document.getElementById("fade").style.opacity=v;
}
function reset(){
  fade(0);
  playing=false;
  camX=camY=velX=velY=0;
  createParticles();
}
</script>

</body>
</html>
